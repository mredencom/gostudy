package main

import "fmt"

/**
	选择排序的基本思想是：
		如果有N个元素需要排序，
		那么首先从N个元素中找到
		最小的那个元素与第0位置
		上的元素交换（说明一点，
		如果没有比原本在第0位置上
		的元素小的就不用交换了，
		后面的同样是），然后再从
		剩下的N-1个元素中找到最小
		的元素与第1位置上的元素交换，
		之后再从剩下的N-2个元素中找到
		最小的元素与第2位置上的元素交换，
		…直到所有元素都排序好（也就是直到从剩下的2个元素中找到最小的元素与第N-2位置上的元素交换）。
	选择排序 时间复杂度：n的平方 空间复杂度：1
 */
//选择排序1
func SelectionSort(s []int) {
	l := len(s)
	m := len(s) - 1
	for i := 0; i < m; i++ {
		k := i
		for j := i + 1; j < l; j++ {
			if s[j] < s[k] {
				k = j
			}
		}
		if k != i {
			s[k], s[i] = s[i], s[k]
		}
	}
}

//选择排序2
/**
	选择排序，就是直接从待排序数组里选择一个最小(或最大)的数字,每次都拿一个最小数字出来，和剩下的数进行比较，再顺序放入新数组,直到全部拿完

	举个例子，有数组[10, 1, 18, 30, 23, 12, 7, 5, 18, 17]，我们使用从小到大的排序方法

	第一趟，外排下标为0，对应数组值10

	内排开始

	①下标0和下标1的值进行比较。10和1比，发现1比10小，进行互换，内排一次完成，结果是[1, 10, 18, 30, 23, 12, 7, 5, 18, 17]

	②下标0和下标2的值进行比较。因为经过了前面的一次内排，这个时候下标0的值是1了，1和18比，1比18小，保持不变，结果是[1, 10, 18, 30, 23, 12, 7, 5, 18, 17]

	③下标0和下标3的值进行比较。因为经过了前面的一次内排，这个时候下标0的值是1了，1和30比，1比30小，保持不变，结果是[1, 10, 18, 30, 23, 12, 7, 5, 18, 17]

	……一直这样比下去，直到1和最后一个元素17进行对比

	第一趟比较结束，结果是[1, 10, 18, 30, 23, 12, 7, 5, 18, 17]，我们发现1是整个数组中最小的元素，放在在前面了，符合预期

	第二趟，外排下标为1，对应数组值10

	内排开始

	①下标1和下标2的值进行比较。10和18比，发现10比18小，保持不变，内排一次完成，结果是[1, 10, 18, 30, 23, 12, 7, 5, 18, 17]

	②下标1和下标3的值进行比较。10和30比，发现10比30小，保持不变，内排二次完成，结果是[1, 10, 18, 30, 23, 12, 7, 5, 18, 17]

	…………

	⑤下标1和下标6的值进行比较。10和7比，发现10比7大，进行互换，内排5次完成，结果是[1, 7, 18, 30, 23, 12, 10, 5, 18, 17]

	⑥下标1和下标7的值进行比较。经过上一次排列，下标1的值为7，7和5比，发现7比5大，进行互换，内排6次完成，结果是[1, 5, 18, 30, 23, 12, 10, 7, 18, 17]

	…………经过一系列排序，结束，结果为[1, 5, 18, 30, 23, 12, 10, 7, 18, 17]

	第三趟

	…………结果为[1, 5, 7, 30, 23, 18, 12, 10, 18, 17]

	…………

	…………

	最终结果为[1, 5, 7, 10, 12, 17, 18, 18, 23, 30]

	至此，排序完成。
 */
func selectSort(theArray []int) []int {
	for i := 0; i < len(theArray); i++ {
		for j := i; j < len(theArray); j++ {
			if theArray[i] < theArray[j] {
				//置换
				theArray[i], theArray[j] = theArray[j], theArray[i]
			}
		}
	}
	return theArray
}
func main() {
	s := []int{9, 0, 6, 5, 8, 2, 1, 7, 4, 3}
	fmt.Println(s)
	SelectionSort(s)
	fmt.Println(s)
	var theArray = []int{10, 1, 18, 30, 23, 12, 7, 5, 18, 17}
	fmt.Println(selectSort(theArray))
}
